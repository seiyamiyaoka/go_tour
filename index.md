# go tour

### packagesとは
goのプログラムの構成のこと

### プログラムの開始はどこから
mainパッケージから開始される

### importの規約とは
パッケージ名は最後の名前と同じになる。import元がURLであっても同じ

### 大文字で始まる名前は何
外部のパッケージから参照できるエクスポートされた名前(公開されている名前という意味)

```
Piはmathパッケージでエクスポートされている
```

### 関数の中での変数に利用方法は

短縮系の下のものが使われる
```
:=
```

### 文字列から数値変換するにはどうするの

標準ライブラリの```strconv```を使う

```
import (
  strconv
)

i, _ := strconv.Atoi(str)
```

### 定数について

constを使う。
文字, 文字列, 数値, boolでのみ利用可能

同系統の変換はそのまま型で挟めば変換できそうだが全く別のもの string => numなどはライブラリを使うのかも

### int型のdefaultの値は
テストを書いた結果0だった

### naked returnとは
名前をつけた戻り値の変数を使うこと。returnする時に返す値を指定しなくて良い

## 関数について

### パラメータとなる引数の使い方は
変数名の後ろに型名をつけるのを気をつける

### まとめ

goにおける型の使い方をみた。変数の使い方に気をつける

## 制御構文(繰り返し文含む)

### for
```go
result := 0
for i := 0; i <= num; i++ {
  result += i
}
```

初期化と後処理(3つ目にくるi++)は省略可能。しかしセミコロンは省略できない。
省略するとwhile文と同じ挙動になる。ループ条件を省略すると無限ループが作成できる

### switch

### deferとは
deferに渡した関数の実行を最後にreturnされるまで取っておきreturnされたら実行するようにする.
deferという言葉には延期するという意味がある

### deferを複数回使うと呼び出される順番はどうなる
deferがスタックされる(last in first out)
最後に入ったものが最初に出て来る


### まとめ
制御構文と繰り返し文の使い方を知った。あわせてニュートン法についてもアルゴリズムがわかったので最高


## 別ファイルの切り出し方

### 別ファイルに切り出した関数の使い方

javaみたいにpackage単位でグループ化して使うみたい。
1. 適当にディレクトリを作成してその中にファイルを作成
2. 作成したファイル名にふさわしいグループ名をつける
3. 関数名は大文字である必要がある

### 呼び出すとき

importにaliasつき

## testについてみてみる

### 実行方法
```
go test ファイル名 #これでテスト実行
```

### ファイル名
Test関数名_test.go


```go Test関数名_test.go
package main

import (
	"math"
	"testing"
)

func TestAbs(t *testing.T) {
	got := math.Abs(-1)
	if got != 1 {
		t.Errorf("Abs(-1) = %f; wand 1", got)
	}
}

```

testingtoolをインポートすると評価することができる。


## ニュートン法とは
方程式を反復した数値計算によって導くもの

f(x) = 0となるような値xが知りたい

ある値x1における切片x2はx1より値xに近く。
これをx3, 4, 5と繰り返せば求めたい答えに近づくことになる。

メモ帳に計算式あり。


```go
// ルート2の値をもとめる方法
// zは何でもいい
package main

import (
	"fmt"
	"math"
)

func Sqrt(x float64) float64 {
	z := 500.0
	for v := 1; v < 16; v++ {
		z = z - ((math.Pow(z, 2) - 2.0) / (2.0 * z))
	}
	return z
}

func main() {
	fmt.Println(Sqrt(2))
	fmt.Println(math.Sqrt(2))
}

```